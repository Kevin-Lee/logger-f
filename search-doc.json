[{"title":"For Cats Effect","type":0,"sectionRef":"#","url":"docs/cats-effect/cats-effect","content":"","keywords":""},{"title":"LoggerF for Cats Effect (WIP)","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#loggerf-for-cats-effect-wip","content":""},{"title":"Log","type":1,"pageTitle":"For Cats Effect","url":"docs/cats-effect/cats-effect#log","content":""},{"title":"Log - Cats","type":0,"sectionRef":"#","url":"docs/cats-effect/log","content":"","keywords":""},{"title":"Log - Cats (WIP)","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log---cats-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[Either[A, B]], OptionT[F, A] and EitherT[F, A, B]. It requires EffectConstructor from Effectie and Monad from Cats. "},{"title":"Log F[A]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-fa","content":"Copy Log[F].log(F[A])(A => String) "},{"title":"Example","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#example","content":"Copy trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person => s\"${person.givenName.givenName} ${person.surname.surname}\" } import cats._ import cats.implicits._ import cats.effect._ import effectie.cats.EffectConstructor import effectie.cats.ConsoleEffect import effectie.cats.Effectful._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: EffectConstructor: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name <- log(effectOf(Named[A].name(a)))(x => info(s\"The name is $x\")) greeting <- pureOf(s\"Hello $name\") } yield greeting } } object MyApp extends IOApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(\"MyApp\") def run(args: List[String]): IO[ExitCode] = for { greetingMessage <- Greeting[IO].greet(Person(GivenName(\"Kevin\"), Surname(\"Lee\"))) _ <- ConsoleEffect[IO].putStrLn(greetingMessage) } yield ExitCode.Success } Copy 21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee "},{"title":"Log F[Option[A]]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-optiontf-a","content":""},{"title":"Log F[Either[A, B]]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-feithera-b","content":""},{"title":"Log EitherT[F, A, B]","type":1,"pageTitle":"Log - Cats","url":"docs/cats-effect/log#log-eithertf-a-b","content":""},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/","content":"","keywords":""},{"title":" LoggerF - Logger for F[_]","type":1,"pageTitle":"Getting Started","url":"docs/#loggerf---logger-for-f_","content":"LoggerF is a tool for logging tagless final with an effect library. LoggerF requires Effectie to construct F[_]. All the example code in this doc site uses Effectie so if you're not familiar with it, please check out Effectie website. Why LoggerF? Why not just log with map or flatMap? Please read \"Why?\" section. "},{"title":"Getting Started","type":1,"pageTitle":"Getting Started","url":"docs/#getting-started","content":""},{"title":"Get LoggerF For Cats Effect","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-cats-effect","content":"With SLF4J# In build.sbt, Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-slf4j\" % \"1.6.0\" ) With Log4j# Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-log4j\" % \"1.6.0\" ) With Log4s# Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-log4s\" % \"1.6.0\" ) With sbt Logging Util# You probably need logger-f for sbt plugin development. Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-cats-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-sbt-logging\" % \"1.6.0\" ) "},{"title":"Get LoggerF For Scalaz Effect","type":1,"pageTitle":"Getting Started","url":"docs/#get-loggerf-for-scalaz-effect","content":"With SLF4J# In build.sbt, Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-slf4j\" % \"1.6.0\" ) With Log4j# In build.sbt, Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-log4j\" % \"1.6.0\" ) With Log4s# In build.sbt, Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-log4s\" % \"1.6.0\" ) With sbt Logging Util# In build.sbt, Copy libraryDependencies ++= Seq( \"io.kevinlee\" %% \"logger-f-scalaz-effect\" % \"1.6.0\", \"io.kevinlee\" %% \"logger-f-sbt-logging\" % \"1.6.0\" ) "},{"title":"Why","type":1,"pageTitle":"Getting Started","url":"docs/#why","content":"If you use some effect library like Cats Effect or Scalaz Effect and tagless final, you may have inconvenience in logging. What inconvenience? I can just log with flatMap like. Copy for { a <- foo(n) // F[A] _ <- effectOf(logger.debug(s\"blah blah $a\")) b <- bar(a) // F[A] } yield b That's true but what happens if you want to use Option or Either? If you use them with tagless final, you may get the result you want. e.g.) Copy import cats._ import cats.implicits._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : EffectConstructor : Monad](n: Int): F[Option[Int]] = for { a <- effectOf(n.some) b <- effectOf(none[Int]) c <- effectOf(123.some) } yield c foo[IO](1).unsafeRunSync() // You expect None here!!! // res1: Option[Int] = Some(value = 123) You expect None for the result due to effectOf(none[Int]) yet you get Some(123) instead. That's because b is Option[Int] not Int. The same issue exists for F[Either[A, B]] as well. So you need to use OptionT for F[Option[A]] and EitherT for F[Either[A, B]]. Let's write it again with OptionT. Copy import cats._ import cats.data._ import cats.implicits._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ def foo[F[_] : EffectConstructor : Monad](n: Int): F[Option[Int]] = (for { a <- OptionT(effectOf(n.some)) b <- OptionT(effectOf(none[Int])) c <- OptionT(effectOf(123.some)) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res3: Option[Int] = None The problem's gone! Now each flatMap handles only Some case and that's what you want. However, because of that, it's hard to log None case. LoggerF can solve this issue for you. Copy import cats._ import cats.data._ import cats.implicits._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val logger: CanLog = Slf4JLogger.slf4JCanLog(\"MyLogger\") // logger: CanLog = loggerf.logger.Slf4JLogger@172ee4c def foo[F[_] : EffectConstructor : Monad : Log](n: Int): F[Option[Int]] = (for { a <- log(OptionT(effectOf(n.some)))( ifEmpty = error(\"a is empty\"), a => debug(s\"a is $a\") ) b <- log(OptionT(effectOf(none[Int])))( error(\"b is empty\"), b => debug(s\"b is $b\") ) c <- log(OptionT(effectOf(123.some)))( warn(\"c is empty\"), c => debug(s\"c is $c\") ) } yield c).value foo[IO](1).unsafeRunSync() // You expect None here. // res5: Option[Int] = None With logs like Copy 00:17:33.983 [main] DEBUG MyLogger - a is 1 00:17:33.995 [main] ERROR MyLogger - b is empty  Another example with EitherT, Copy import cats._ import cats.data._ import cats.implicits._ import cats.effect._ import effectie.cats.Effectful._ import effectie.cats._ import loggerf.cats._ import loggerf.logger._ import loggerf.syntax._ // or Slf4JLogger.slf4JLogger[MyClass] implicit val logger: CanLog = Slf4JLogger.slf4JCanLog(\"MyLogger\") // logger: CanLog = loggerf.logger.Slf4JLogger@585bfab5 def foo[F[_] : EffectConstructor : Monad : Log](n: Int): F[Either[String, Int]] = (for { a <- log(EitherT(effectOf(n.asRight[String])))( err => error(s\"Error: $err\"), a => debug(s\"a is $a\") ) b <- log(EitherT(effectOf(\"Some Error\".asLeft[Int])))( err => error(s\"Error: $err\"), b => debug(s\"b is $b\") ) c <- log(EitherT(effectOf(123.asRight[String])))( err => warn(s\"Error: $err\"), c => debug(s\"c is $c\") ) } yield c).value foo[IO](1).unsafeRunSync() // You expect Left(\"Some Error\") here. // res7: Either[String, Int] = Left(value = \"Some Error\") With logs like Copy 00:40:48.663 [main] DEBUG MyLogger - a is 1 00:40:48.667 [main] ERROR MyLogger - Error: Some Error "},{"title":"Usage","type":1,"pageTitle":"Getting Started","url":"docs/#usage","content":"Pleae check out LoggerF for Cats EffectLoggerF for Scalaz Effect "},{"title":"Log - Scalaz","type":0,"sectionRef":"#","url":"docs/scalaz-effect/log","content":"","keywords":""},{"title":"Log - Scalaz (WIP)","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log---scalaz-wip","content":"Log is a typeclass to log F[A], F[Option[A]], F[A \\/ B], OptionT[F, A] and EitherT[F, A, B]. It requires EffectConstructor from Effectie and Monad from Scalaz. "},{"title":"Log F[A]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-fa","content":"Copy Log[F].log(F[A])(A => String) "},{"title":"Example","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#example","content":"Copy trait Named[A] { def name(a: A): String } object Named { def apply[A: Named]: Named[A] = implicitly[Named[A]] } final case class GivenName(givenName: String) extends AnyVal final case class Surname(surname: String) extends AnyVal final case class Person(givenName: GivenName, surname: Surname) object Person { implicit val namedPerson: Named[Person] = person => s\"${person.givenName.givenName} ${person.surname.surname}\" } import scalaz._ import Scalaz._ import scalaz.effect._ import effectie.scalaz.EffectConstructor import effectie.scalaz.ConsoleEffect import effectie.scalaz.Effectful._ import loggerf.logger._ import loggerf.scalaz._ import loggerf.syntax._ trait Greeting[F[_]] { def greet[A: Named](a: A): F[String] } object Greeting { def apply[F[_] : Greeting]: Greeting[F] = implicitly[Greeting[F]] implicit def hello[F[_]: EffectConstructor: Monad: Log]: Greeting[F] = new Greeting[F] { def greet[A: Named](a: A): F[String] = for { name <- log(effectOf(Named[A].name(a)))(x => info(s\"The name is $x\")) greeting <- pureOf(s\"Hello $name\") } yield greeting } } object MyApp { implicit val canLog: CanLog = Slf4JLogger.slf4JCanLog(\"MyApp\") def run(args: List[String]): IO[Unit] = for { greetingMessage <- Greeting[IO].greet(Person(GivenName(\"Kevin\"), Surname(\"Lee\"))) _ <- ConsoleEffect[IO].putStrLn(greetingMessage) } yield () def main(args: Array[String]): Unit = run(args.toList).unsafePerformIO() } Copy 21:02:15.323 [ioapp-compute-0] INFO MyApp - The name is Kevin Lee Hello Kevin Lee "},{"title":"Log F[Option[A]]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-foptiona","content":""},{"title":"Log OptionT[F, A]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-optiontf-a","content":""},{"title":"Log F[A \\/ B]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-fa--b","content":""},{"title":"Log EitherT[F, A, B]","type":1,"pageTitle":"Log - Scalaz","url":"docs/scalaz-effect/log#log-eithertf-a-b","content":""},{"title":"For Scalaz Effect","type":0,"sectionRef":"#","url":"docs/scalaz-effect/scalaz-effect","content":"","keywords":""},{"title":"LoggerF for Scalaz Effect (WIP)","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#loggerf-for-scalaz-effect-wip","content":""},{"title":"Log","type":1,"pageTitle":"For Scalaz Effect","url":"docs/scalaz-effect/scalaz-effect#log","content":""}]